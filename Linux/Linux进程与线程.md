# Linux进程管理

## 进程处理

### `system()`

利用system()库函数调用子进程

` int system(char* command); `

内部调用fork(), execve(), waitpid 等系统调用

### `fork()`

- ` pid_t fork(void);`
- 执行fork复制父进程代码，创建子进程，从fork之后开始执行
- 父进程返回子进程的pid，子进程返回0，错误返回-1
- 不需要传参，但**返回值**很重要，fork会在两个进程中均返回
- 利用复制共享的方式，只有遇到写操作时才复制创建新的页（代码段只读，所以不会被复制）
- 子进程PCB也会获得父进程文件描述符表的副本，但共享文件表项（含有引用计数来保证子进程关闭后父进程无法使用文件的情况）
- 

```cpp
#include <sys/types.h> //pid这种类型所在
#include <unistd.h> //系统调用

int main()
{
	//fork之间父进程中运行
	pid_t pid = fork(); //fork()会在两个进程中均返回值
	//fork后内容父子进程均运行
	if(pid == 0)
	{
		//子进程
	}
	else 
	{
		//父进程内容
	}	
}
```

### `getpid() getppid()` 

- getpid返回当前进程的进程号
- getppid返回父进程的进程号

### `sleep()`

- 休眠阻塞当前进程
- 可以被信号唤醒

### `execve()`

1. **加载新的程序**：当进程调用 `execve` 时，操作系统会用指定的程序替换当前进程的代码段、数据段、堆和栈。当前进程的内存映像被新程序的映像所替代。
2. **保留进程标识符（PID）**：尽管当前进程的内存映像被替换，进程的标识符（PID）保持不变。也就是说，调用 `execve` 后，进程会继续拥有原来进程的 PID 和资源句柄（如打开的文件描述符）。
3. **环境和参数**：`argv[]` 和 `envp[]` 会被传递给新的程序，作为该程序的命令行参数和环境变量。
4. **文件描述符**：`execve` 调用不会关闭当前进程的打开文件描述符，因此父进程打开的文件描述符（如果没有设置为 `FD_CLOEXEC`）会继续对新程序可用。
5. **返回值**：如果 `execve` 成功，它不会返回，因为当前进程的映像已被替换。若调用失败，则返回 `-1`，并设置 `errno` 以指示错误原因。

```cpp
int execve(const char* path, char* const argv[], char* const envp[] );
path：执行程序路径
argv：传入的参数 -> main中第二个参数格式一致
	（1）：第一个参数固定式程序名（路径）
	（2）：需要传入的参数
	（3）：最后一个参数为NULL
envp[]：环境变量 （win里面的类似）
    可以什么都不传直接空数组
    （1）：环境变量参数：key=value
    （2）：最后一个为NULL
返回：
    成功无法返回 下面的代码没有意义
	失败返回-1
    
if(execve() == -1) error; 
//后续内容没有意义

和fork使用来创建子进程，然后执行其他函数

```

### `waitpid()`



### 进程树

- 进程具有父进程祖先进程，可以构造出一个树状结构

### 孤儿进程

- 父进程先结束，那么子进程会变为孤儿进程，绑定到他的祖先进程上

### 僵尸进程

- 



## 进程通信

 



## 线程处理

**线程**

- 线程是进程内的执行单元，共享相同的地址空间和其他资源，但每一个线程都有自己的栈空间
- 父线程结束会强制杀死子线程
- exit线程自己终止，detach父线程不挂起终止，cancel延迟终止

- `pthread_cancel` 不会强制终止线程，而是依赖线程运行到取消点（如 `sleep`、`read`）。如果线程中没有取消点，可以手动调用 `pthread_testcancel`：



## 线程同步

### 互斥锁

- 可以动态初始化也可以静态初始化，c中动态初始化使用初始化函数，静态初始化使用static或者全局变量以及宏来进行



### 读写锁

- 多个线程可以同时获得读锁
- 若有至少一个读操作占有读锁，则无法获得写锁
- **读者写者问题**，只不过封装好了
- 但没有写优先，写优先可以修改锁的属性来处理，在初始化时
- 

### 自旋锁

- 几乎不会用到
- 忙等待锁，而非阻塞，用于很小的操作避免进程阻塞和唤醒的开销

### 条件变量

- 符合掉条件时释放锁，用于获得锁后更加灵活的占有资源
- 条件变量是互斥锁的补充

## 信号量

  













<img src="C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20241123175157840.png" alt="image-20241123175157840" style="zoom: 80%;" />

<img src="C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20241123180419220.png" alt="image-20241123180419220" style="zoom: 67%;" />







